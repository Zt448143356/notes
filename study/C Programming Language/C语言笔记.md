# 基础信息

## C语言的数据类型

### 基本类型：所谓“基本”，是指其值不可以再分解的数据类型。

#### 整型( `int` )

#### 实型：

* 单精度( `float` )
* 双精度( `double` )

#### 字符型（ `char` ）

#### 枚举类型（ `enum` ）

#### 构造类型：利用现有的一个或多个数据类型构造新的数据类型

* 数组类型  ( `[]` )
* 结构体类型( `struct` )
* 共用体类型( `union` )

#### 指针类型：用于表示某个变量在内存中的地址

#### 空类型：类型说明符为 `void` ，常用来定义没有返回值的函数

#### 注意点

* 还有一些不常用的类型以及所有的范围（不同编译环境不一样）：

``` code
     char -128 ~ +127 (1 Byte)
     short -32767 ~ + 32768 (2 Bytes)
     unsigned short 0 ~ 65536 (2 Bytes)
     int -2147483648 ~ +2147483647 (4 Bytes)
     unsigned int 0 ~ 4294967295 (4 Bytes)
     long == int
     long long -9223372036854775808 ~ +9223372036854775807 (8 Bytes)
     double 1.7 * 10^308 (8 Bytes)

     unsigned int 0～4294967295 
     long long的最大值：9223372036854775807
     long long的最小值：-9223372036854775808
     unsigned long long的最大值：1844674407370955161

     __int64的最大值：9223372036854775807
     __int64的最小值：-9223372036854775808
     unsigned __int64的最大值：18446744073709551615
```

## 变量

* 变量必须先定义后使用。定义变量时，系统自动检测出所需要的存储空间大小，然后为变量分配存储单元
* 标识符只能由字母、数字和下划线组成，且第一个字符必为字母或下划线

### C语言变量名的命名规则：（可以字母，数字，下划线混合使用） 

01. 只能以字母或下划线开始； 
02. 不能以数字开始； 
03. 一般小写； 
04. 不允许占用关键字

### 函数名的命名规则 

01. 见名知意； 
02. 自定义函数函数名首字母大写（库函数里的函数名都是以小写字母定义，为了区分库函数和自定义函数，避免冲突）。 

### 宏定义里面的变量 全大写(小写也通过了编译)

* `#define SIZE 100` (后面函数所有出现的 `SIZE` 全用 `100` 代替，它在所有函数执行前先执行)

## 常量

01. 字面常量：整型常量，实型常量，字符型常量（必用''（英文输入下的单引号））
02. 符号常量：用一个标识符代表一个常量        #define 标识符 常量
03. `const` 常量：
    - 只读常量： `const` 类型标识符 变量标识符 `=` 初始化数据 
    - 或者  类型标识符 `const` 变量标识符 `=` 初始化数据 
    - 只能在定义时初始化，之后不能进行赋值

## 八进制前缀是 `0` ，十六进制前缀是 `0X`

## 整型

### 整型数据的输入和输出

01. 标准输入输出文件

    - `#include<stdio.h>`

    - `#include:` 预处理命令，将头文件包含到用户的源程序
    - `stdio.h:` 标准输入输出头文件，提供输入和输出函数的原型
    - 输出、入控制符

02. `printf` 的用法：

    - `printf("字符串")`

    - `printf("输出控制符"，输出参数)`

    - `printf("输出控制符1 输出控制符2....."，输出参数1，输出参数2.....)` 个数必须匹配
    - `printf("输出控制符 非输出控制符（如转义字符）"，输出参数)`

    - 为什么需要输出控制符：

         * 如 `01` 组成的代码可以表示数据也可以表示指令
         * 如果 `01` 组成的代码表示数据，那么同样的 `01` 代码组合以不同的输出就有不同的输出结果

03. `scanf` 用法：
    - 将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入以输入参数的值为地址的变量中
    - `scanf("输入控制符"，输入项地址列表)`

    - `scanf("非输入控制符 输入控制符"，输入参数)`

    - 非输入控制符必须原样输入

``` 

例：scanf("m%d",&i)
若键盘敲入：m123n，则输出i显示123
若键盘敲入：123，则输出i显示为原来的此空间的数（我也不知道是什么数）
scanf("%d,%d,%d",&i,&j,&k);
printf("i = %d,j = %d, k = %d",i , j, k);
若键盘敲入：1（空格）2（空格）3
则输出：i = 1,j = (乱码，不可预知)，3 = （乱码）
应当输入1,2,3
则输出：i = 1,j = 2,k = 3
所以输入的字符不能丢弃","

scanf("%c",&a);会记录回车符，即'\n'也会输入到a中，但%s就不会，%s以空格和回车作为结束
```

### 整型数据在内存中的存储方式

* 以补码的形式存储，正数的源码、反码、补码一样；负数的补码=反码+1

## 实型

### 实型常量与变量

| 名称        |  位数 | 有效数字 |
|-------------|:-----:|:------:|
| float       |   32  |   6~7  |
| double      |   64  |  15~16 |
| long double |   64  |  15~16 |

* 浮点数的有效数字位决定数据的精度
* 浮点型数据非准确存储

## 实型数据的输入和输出：        

* `m.n`

* `m` 为域宽 `n` 为精度  
* 高精度与低精度运算，结果为高精度 
* `printf("%5.2f",1.234)`

* 结果为 `__1.23` 1.23前面两个空格

### 实型数据在内存中的存储方式

* 有效位数之外的将舍弃，因此有效数字的位数决定精度
* 将一个实属表示成小数部分和指数部分，分别存放
* 如：+123.567

| 数的符号位 | 数字部分 | 指数的符号位 |  指数 |
|:--------:|:------:|:----------:|:-----:|
|     +    | 123567 |      +     |   3   |

      
    

## 字符型常量、转义字符与变量

01. 字符常量：用‘’将其括起来
02. 转义字符：“\”后跟一个字符，代表一个特殊控制字符
03. 字符型变量：char,一个字符型变量占一个字节的内存空间，可存放一个字符
04. 字符型数据的输入输出：

   + 基本输入输出函数： `i = getchar(),putchar(i)`

   + 格式输入输出函数： `scanf,printf`

05. 字符串用“”括起来，包括转义字符

## 运算优先级

* 算数 `>` 关系 `>` 赋值 `>` 逻辑

## 数据类型的转换

01. 隐式转换：

   + 转换使数据的字节长度变长，精度变高.
   + 如: `float` 到 `double` , `short` 和 `char` 到 `int`

   + 赋值时，等号两边数据精度不同，则右边变为左边
   + 如： int i = 1.234; //i为1

02. 强制类型转换：

   + （类型名）（表达式）
   + 只将结果进行临时转换，不改变变量的数据类型
   + 如：double k = 1.234; 
   + int i  = (int)k; // i 为 1

# 语法部分

## 逻辑运算符和逻辑表达式

* `a&&b&&c`     
* `a`为假时，不再判断`b`, `c`；只有`a`真，`b`真的情况下，才判断`c`
* `a || b || c`        
* `a`为真，则不再判断`b`, `c`；只有`a`假，`b`假的情况下，才判断`c`

## 常用语法部分

01. if    

          if(表达式)          //表达式为真，else后面不跟判断语句
               语句;
          else                   //else总与它前面最近的未配对的if配对
               语句；

02. switch

     switch(变量或常量)                    //各个case和default的先后次序不影响运行
     {
          case 常量表达式 : 语句 ;          //可在每个case后加break，来跳出switch否则将执行下一个case
          .......                    .....
          default : 语句;                    //若匹配的case没有语句，将执行下一个case的语句
     }

03. 表达式1 ？ 表达式2：表达式3

     1为真，则执行2，否则执行3

04. while

     while（表达式P）          //先判断P，为真则进入循环
     ｛循环语句｝               //在循环语句中要有使P为假的语句

05. do... .while

     do
     {循环语句}		  //先执行一次，无论符不符合条件
     while(表达式P)；     //P为真时，执行循环

06. for

     for(表达式1；表达式2；表达式3)     //先执行表达式1，通常为赋值；表达式2为真，则循环；表达式3通常改变循环变量
     ｛循环语句｝          //三个表达式均能省，但‘;’不行

07. break

     （1）跳出switch结构，并继续执行switch结构之后的语句
     （2）跳出最近的循环语句，并继续执行循环结构之外的语句
     （3）不能直接用于if

08. continue

          结束本次循环，继续进行下次循环          //不能用于switch内（只能用于循环语句）

09. goto

     无条件转向语句：          goto  语句符号；
     与if组合，可成为循环体；在循环体内可跳出循环体；
     但goto使程序流程无规律，限制使用

## 数组
 

01. 一维数组的定义：

          数据类型 <数组名>[常量表达式]     ——不包括变量
          int a[0] ；    返回值为a[0]的首地址
    在对数组全部元素赋初值时，可以不指定数组的长度，数组长度与初始化的元素个数相等

如： int a[ ] = {1, 2, 3} ; 数组长度为3

     定义：（1）为n个变量连续分配存储空间
               （2）所有的变量数据类型必须相同
               （3）所有变量所占字节大小必须相同

     初始化：

          （1）完全初始化： int a[5] = {1, 2, 3, 4, 5} ; 
          （2）不完全初始化： int a[5] = {1,2,3} ;  //为初始化部分自动天0
          （3）不初始化： int a[5] ;   //所有元素为未知值
          （4）清零 ： int a[5] = {0} ;
     只有在定义数组的同时才可以整体赋值，其他情况下整体赋值都为错

02. 二维数组的定义

数据类型 <数组名>[常量表达式1][常量表达式2] //表达式1为行，表达式2为列

     若二维数组的所有元素都初始化数值或分行初始化数值时，第一维度可以为空，第二维度不能省略
          如：  int a[][2] = {{1,2},{3,4}} ;

03. 多维数组

     不存在多位数组，因为内存是线性一维的；n为数组可以当作每个元素是n-1维数组的一维数组
     只是我们可以变相的去这样理解
	如a[2][2]
	真正上:a[0][0] a[0][1] a[1][0] a[1][1] (是一条的)
	我们认为:a[0][0]a[0][1]
		   a[1][0]a[1][1]

## 字符串

01. 字符数组的定义和使用

     数组元素在使用时，仅看作字符类型的变量
     （1）字符数组的元素用%c格式进行输入输出
     （2）字符数组元素可以和其他元素一样处理
     （3）未被初始化的元素将被赋值为0，即字符 ‘\0’

02. 字符串数组

     字符串依次存放在字符数组中，在有效字符的后面以‘\0’作为结束标志
     char a[] = {"i am "} ;
     char a[] = "i am " ;
     （1）使用%s进行输入字符串
     （2）使用gets和puts输入输出     gets(s1)  gets(2)

03. 字符串处理函数          string.h(头文件)

     （1）strlen（字符串） 用于计算字符串的有效字符的长度

     （2）strupr（字符串）     小写变大写
          strlur（字符串）     大写变小写          都返回字符串的首地址

    
     （3）strcpy（字符串1，字符串2）
               将字符串2中的所有字符复制到1中，返回1的首地址
               1的长度必须超过2，2可以是常量字符，也可以是字符数组中存放的字符串

     （4）strcat（字符数组1，字符数组2）
               将2连在1之后，并保存在1中，返回1的首地址
               1的长度必须大于字符串1和2的长度之和；
               2可以是常量字符串，也可以是字符数组中存放的字符串；
               1中的‘\0’被删除，然后连接2

     （5）strcmp（字符串1，字符串2）
               比较两个字符串大小。从左到右依次比较，知道出现不同字符或‘\0’
               若1>2，则返回值为正； = 返回值为0；< 返回值为负

 
 
## 函数

01. 函数的定义

     函数类型 <函数名> （[<形参表>]）
     ｛
          声明部分；
          执行语句部分；
     ｝

     （1）函数中不能再嵌套定义函数
     （2）不论return语句返回值为何种类型，都将自动转换为函数类型
     （3）空函数什么都不做

02. 函数调用

     函数定义后，才能调用。
     如果函数定义中有形参，在调用时，应传递实际参数
     函数调用的一般形式：
          <函数名> （[<实参表>]）
     （1）实参与形参的类型，个数和位置应一一对应
     （2）实参与形参的变量名可一致，也可不一致
    
     若函数写在主函数之后，需加函数声明     声明时要‘；’

03. 参数的传递

     函数传递的方向是单向传递；实参和形参所占内存不同
     如果实参列表包括了多个实参，则执行顺序不确定（VC++中先右后左）

04. 函数返回值

     （1）无论返回值为何种数据类型，都将自动转换为函数类型
     （2）函数类型可以省略，默认为int
     （3）return 可以退出或结束函数
     （4）一个函数有多个return语句，执行哪一个则带回哪一个的返回值
     （5）void 函数无返回值

   

05. 局部变量和全局变量

     局部变量：作用范围只在函数内部的变量，函数内部定义
     全局变量：函数外部定义，作用范围从定义位置到该文件结束
     （1）若局部变量与全局变量名称相同，则优先使用局部变量
     （2）全局变量在全部执行过程中都占用内存
     （3）尽量避免使用全局变量

06. 变量的存储类别和生存期

     动态存储方式：（1）函数形式参数     （2）函数内部定义的变量     函数结束时，释放空间
     静态存储方式：（1）全局变量     （2）被static定义的局部变量     （静态存储变量默认为0）
     （1）auto：默认，现在没什么用了
     （2）static：声明静态局部变量（注意与JAVA中的不同）
     （3）register：将变量放入cpu内部的寄存器，从而提高效率
     （4）extern：声明变量是定义在其他文件中的外部变量

     静态存储方式定义的内容，仅能在本函数使用么不能外部引用

## 地址和指针

     地址：内存单元的编号
     指针：内存单元的地址
     所以，地址 == 指针

01. 变量的指针和指向变量的指针变量

     变量的指针：变量的地址
     指针变量：用于存放指针的变量
     定义：     类型说明符 * 指针变量名           例：int *a;
     与指针相关的运算符： （1） &：取地址符
                          （2） *  ：指针运算符（取得该指针的内容）
          定义中的*仅是一个表示，指出它后面的变量是指针变量

     两个指针变量指向同一块连续空间中的不同存储单元，则可以相减
     指针变量只占4个字节

02. 数组的指针和指向数组的指针变量

     数组名代表数组的首地址，即第0号元素的地址          a == &a[0]
     若 p = &a[0]     则 : p+i == a+i ==&a[i]
     *与++的优先级相同，所以自右向左：     *p++ == *(p++)               *++p == *(++p)

03. 多维数组

     a[i][j] == *(a[i]+j) == *(*(a+i)+j)

04. 字符串

     字符串的表示形式：
          （1）用字符数组从存放或处理字符串
                    char a[] = "I LOVE"     ;
          （2）用字符指针指向字符串
                    char *a = "I LOVE"     ;

     注意：（1）字符指针变量是一个变量，用于存放字符串的首地址
                         字符串本身是存放在以该地址为首的一块连续的内存空间中
               （2）对字符指针变量赋初值
               （3）指针变量未取得确定地址时，不要用

05. 指针与函数

     函数名是函数所占内存的首地址，也成为函数的指针
     指向函数的指针变量：
               类型说明符  （*指针变量名）（函数参数列表）;
               例： int (*p)(int ,int )
          调用： （*指针变量名）(实参表)
          例:     int max(int x,int y)
                    {.......}
                   int main()
                    {
                         int (*p)(int ,int);
                         p = max;
                         int a,b,c;
                         c = (*p)(a,b);
                         .......
                    }

        函数指针变量进行算数运算符时无意义
         指向函数的指针，可作为函数参数

     返回指针值的函数：
               类型说明符  * 函数名  （形参表）

06. 指针数组和指向指针的指针

         指针数组：每一个元素都为指针类型
                         类型说明符     * 数组名[数组长度]               int *a[6];
          注： int (*p)[3] : P表示一个指向二维数组的指针变量，列数为3
                 int *p[3]    :P表示一个指针数组，有三个元素
    
     指向指针的指针：
               一个指针变量存放另一个指针变量的地址
               类型说明符     **指针变量名
     注：（1）char **p     ==  char *(*p)
                    p是指向一个字符指针变量的指针变量
           （2）**p == *(*p)
                    *P是取得p指向的指针变量，*（*p）取得其值

07. 动态内存分配

     int *p = (int *) malloc(seizeof(int)) ;
     free(p) ;
    
     动态内存由程序员手动分配，释放，在堆中分配
     静态内存由系统分配，释放，在栈中分配
        calloc函数：一次可以分配n块连续空间
          调用：（类型说明符 *）calloc（n,size）

        区别：malloc函数不能初始化所分配的内存空间，但calloc可以
                   calloc会将分配的内存空间中的每一位都初始化为0
